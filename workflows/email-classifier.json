{
  "name": "Gmail Email Classifier",
  "nodes": [
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "everyX",
              "value": 5,
              "unit": "minutes"
            }
          ]
        },
        "filters": {
          "q": "in:inbox -label:_System/Processed"
        },
        "options": {
          "maxResults": 10
        }
      },
      "id": "gmail-trigger",
      "name": "Gmail Trigger",
      "type": "n8n-nodes-base.gmailTrigger",
      "typeVersion": 1,
      "position": [240, 300],
      "credentials": {
        "gmailOAuth2": {
          "id": "GMAIL_CREDENTIAL_ID",
          "name": "Gmail OAuth2"
        }
      }
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://gmail.googleapis.com/gmail/v1/users/me/labels",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "gmailOAuth2",
        "options": {}
      },
      "id": "fetch-labels",
      "name": "Fetch Labels",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [340, 300],
      "credentials": {
        "gmailOAuth2": {
          "id": "GMAIL_CREDENTIAL_ID",
          "name": "Gmail OAuth2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Cache the Gmail label map in static data and pass through all emails\nconst labelsResponse = $input.first().json;\nconst staticData = $getWorkflowStaticData('global');\n\nconst labelMap = {};\nfor (const l of (labelsResponse.labels || [])) {\n  labelMap[l.name] = l.id;\n}\nstaticData.labelMap = labelMap;\n\n// Pass through ALL emails from Gmail Trigger\nconst emails = $('Gmail Trigger').all();\nreturn emails.map(item => item.json);\n"
      },
      "id": "cache-labels",
      "name": "Cache Labels",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "jsCode": "// Extract and preprocess email content for ALL items\nconst items = $input.all();\nconst sanitize = (str) => str.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\n/g, ' ').replace(/\\r/g, ' ').replace(/\\t/g, ' ');\n\nreturn items.map(item => {\n  const email = item.json;\n\n  const fromHeader = email.payload?.headers?.find(h => h.name === 'From')?.value || email.from?.emailAddress || email.From || '';\n  const senderMatch = fromHeader.match(/<([^>]+)>/) || fromHeader.match(/([\\w.+-]+@[\\w.-]+)/);\n  const senderEmail = senderMatch ? senderMatch[1].toLowerCase() : fromHeader.toLowerCase();\n  const senderDomain = senderEmail.split('@')[1] || '';\n\n  const subject = email.payload?.headers?.find(h => h.name === 'Subject')?.value || email.subject || email.Subject || '(no subject)';\n\n  let body = '';\n  if (email.payload?.body?.data) {\n    body = Buffer.from(email.payload.body.data, 'base64').toString('utf-8');\n  } else if (email.payload?.parts) {\n    const textPart = email.payload.parts.find(p => p.mimeType === 'text/plain');\n    if (textPart?.body?.data) {\n      body = Buffer.from(textPart.body.data, 'base64').toString('utf-8');\n    }\n  } else if (email.textPlain) {\n    body = email.textPlain;\n  }\n\n  body = body.replace(/<[^>]*>/g, ' ');\n  body = body.split('\\n').filter(line => !line.trim().startsWith('>')).join('\\n');\n  body = body.replace(/\\s+/g, ' ').trim();\n\n  return {\n    messageId: email.id,\n    threadId: email.threadId,\n    senderEmail,\n    senderDomain,\n    subject: sanitize(subject),\n    bodyPreview: sanitize(body.substring(0, 1500)),\n    snippet: email.snippet || '',\n    labelIds: email.labelIds || []\n  };\n});\n"
      },
      "id": "preprocess",
      "name": "Preprocess Email",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [600, 300]
    },
    {
      "parameters": {
        "jsCode": "// Check sender cache for known classifications - ALL items\nconst items = $input.all();\nconst staticData = $getWorkflowStaticData('global');\n\nif (!staticData.senderCache) staticData.senderCache = {};\nif (!staticData.domainCache) staticData.domainCache = {};\n\nconst cache = staticData.senderCache;\nconst domainCache = staticData.domainCache;\n\nreturn items.map(item => {\n  const email = item.json;\n\n  if (cache[email.senderEmail]) {\n    const cached = cache[email.senderEmail];\n    return {\n      ...email,\n      cached: true,\n      category: cached.category,\n      priority: cached.priority,\n      action_needed: cached.action_needed,\n      archive: cached.archive,\n      confidence: 0.95,\n      summary: `Cached classification for ${email.senderEmail}`\n    };\n  }\n\n  if (domainCache[email.senderDomain]) {\n    const cached = domainCache[email.senderDomain];\n    return {\n      ...email,\n      cached: true,\n      category: cached.category,\n      priority: cached.priority,\n      action_needed: cached.action_needed,\n      archive: cached.archive,\n      confidence: 0.85,\n      summary: `Domain pattern match for ${email.senderDomain}`\n    };\n  }\n\n  return { ...email, cached: false };\n});\n"
      },
      "id": "cache-check",
      "name": "Check Sender Cache",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.cached }}",
              "value2": true
            }
          ]
        }
      },
      "id": "if-cached",
      "name": "Cached?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [900, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.anthropic.com/v1/messages",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "anthropicApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "anthropic-version",
              "value": "2023-06-01"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"claude-3-5-haiku-20241022\",\n  \"max_tokens\": 256,\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"You are an email classification system. You understand emails in English and Brazilian Portuguese equally well.\\n\\nAnalyze this email and return ONLY valid JSON.\\n\\nCategories (use the most specific sub-category when applicable):\\n- Finance, Finance/Banking, Finance/Receipts, Finance/Bills, Finance/Investments\\n- Work, Work/Projects, Work/Meetings\\n- Personal, Personal/Family, Personal/Health\\n- Shopping, Shopping/Orders, Shopping/Shipping, Shopping/Deals\\n- Travel, Travel/Flights, Travel/Hotels, Travel/Reservations\\n- Notifications, Newsletters, Social, Security, Other\\n\\nPriority Levels:\\n- P1 (Urgent): Response needed within 24h, important contacts, deadlines\\n- P2 (Important): Action needed but not urgent\\n- P3 (Low): Informational, automated, promotional\\n\\nEmail:\\nFrom: {{ $json.senderEmail }}\\nSubject: {{ $json.subject }}\\nBody: {{ $json.bodyPreview.substring(0, 1000) }}\\n\\nReturn JSON:\\n{\\n  \\\"category\\\": \\\"<category>\\\",\\n  \\\"priority\\\": \\\"P1|P2|P3\\\",\\n  \\\"action_needed\\\": true|false,\\n  \\\"archive\\\": true|false,\\n  \\\"confidence\\\": 0.0-1.0,\\n  \\\"summary\\\": \\\"<one sentence in English>\\\"\\n}\\n\\nRules:\\n- Marketing/promotional with fake urgency (Last chance!, So hoje!, Ultima chance!, Aproveite!) = Newsletters, P3, archive=true, confidence>=0.90\\n- Emails from noreply@ or no-reply@ = usually P3, archive=true\\n- Emails with Unsubscribe or Cancelar inscricao = Newsletters, P3, archive=true\\n- CC'd (not To'd) = usually P3\\n- Security alerts (password reset, login attempt) = Security, P1\\n- Receipts/confirmations with no action = Finance/Receipts, P3, archive=true\\n- Bank/financial alerts = Finance/Banking, P2\\n- Order confirmations = Shopping/Orders, P3, archive=true\\n- Shipping/tracking updates = Shopping/Shipping, P3, archive=true\\n- Flight confirmations/boarding passes = Travel/Flights, P3\\n- Hotel confirmations = Travel/Hotels, P3\\n- Other travel bookings (car, tours, restaurant) = Travel/Reservations, P3\\n- Be confident: if clearly promotional or automated, set confidence >= 0.90\\n- Always return valid JSON, nothing else\"\n    }\n  ]\n}",
        "options": {}
      },
      "id": "ai-classify",
      "name": "AI Classification",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1120, 400],
      "credentials": {
        "anthropicApi": {
          "id": "ANTHROPIC_CREDENTIAL_ID",
          "name": "Anthropic API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst emailItems = $('Check Sender Cache').all();\n\nreturn items.map((item, i) => {\n  const aiResponse = item.json;\n  const email = emailItems[i]?.json || {};\n\n  let classification;\n  try {\n    const content = aiResponse.content?.[0]?.text || '';\n    const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n      classification = JSON.parse(jsonMatch[0]);\n    } else {\n      throw new Error('No JSON found in response');\n    }\n  } catch (e) {\n    classification = {\n      category: 'Other',\n      priority: 'P2',\n      action_needed: false,\n      archive: false,\n      confidence: 0.5,\n      summary: 'Classification failed - needs review'\n    };\n  }\n\n  return { ...email, ...classification, cached: false };\n});\n"
      },
      "id": "parse-ai",
      "name": "Parse AI Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 400]
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst staticData = $getWorkflowStaticData('global');\n\nreturn items.map(item => {\n  const email = item.json;\n\n  if (!email.cached && email.confidence >= 0.85) {\n    if (!staticData.senderCache) staticData.senderCache = {};\n    if (!staticData.senderCounts) staticData.senderCounts = {};\n    \n    const key = email.senderEmail;\n    if (!staticData.senderCounts[key]) {\n      staticData.senderCounts[key] = { category: email.category, count: 1 };\n    } else if (staticData.senderCounts[key].category === email.category) {\n      staticData.senderCounts[key].count++;\n    } else {\n      staticData.senderCounts[key] = { category: email.category, count: 1 };\n    }\n    \n    if (staticData.senderCounts[key].count >= 3) {\n      staticData.senderCache[key] = {\n        category: email.category,\n        priority: email.priority,\n        action_needed: email.action_needed,\n        archive: email.archive,\n        addedAt: new Date().toISOString()\n      };\n    }\n  }\n\n  return email;\n});\n"
      },
      "id": "update-cache",
      "name": "Update Cache",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1560, 400]
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nreturn items.map(item => item.json);\n"
      },
      "id": "merge",
      "name": "Merge Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 200]
    },
    {
      "parameters": {
        "conditions": {
          "number": [
            {
              "value1": "={{ $json.confidence }}",
              "operation": "largerEqual",
              "value2": 0.85
            }
          ]
        }
      },
      "id": "confidence-check",
      "name": "High Confidence?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1560, 200]
    },
    {
      "parameters": {
        "jsCode": "// Build label names and resolve to Gmail label IDs - ALL items\nconst items = $input.all();\nconst staticData = $getWorkflowStaticData('global');\nconst labelMap = staticData.labelMap || {};\n\nconst categoryMap = {\n  'Finance': '#Finance',\n  'Finance/Banking': '#Finance/Banking',\n  'Finance/Receipts': '#Finance/Receipts',\n  'Finance/Bills': '#Finance/Bills',\n  'Finance/Investments': '#Finance/Investments',\n  'Work': '#Work',\n  'Work/Projects': '#Work/Projects',\n  'Work/Meetings': '#Work/Meetings',\n  'Personal': '#Personal',\n  'Personal/Family': '#Personal/Family',\n  'Personal/Health': '#Personal/Health',\n  'Shopping': '#Shopping',\n  'Shopping/Orders': '#Shopping/Orders',\n  'Shopping/Shipping': '#Shopping/Shipping',\n  'Shopping/Deals': '#Shopping/Deals',\n  'Travel': '#Travel',\n  'Travel/Flights': '#Travel/Flights',\n  'Travel/Hotels': '#Travel/Hotels',\n  'Travel/Reservations': '#Travel/Reservations',\n  'Notifications': '#Notifications',\n  'Newsletters': '#Newsletters',\n  'Social': '#Social',\n  'Receipts': '#Finance/Receipts',\n  'Security': '#Security',\n  'Other': '#Other'\n};\n\nreturn items.map(item => {\n  const email = item.json;\n  const labelNames = [];\n\n  labelNames.push(categoryMap[email.category] || '#Other');\n\n  if (email.priority === 'P1') {\n    labelNames.push('!Priority/Urgent');\n  } else if (email.priority === 'P2' && email.action_needed) {\n    labelNames.push('@Action/Review');\n  }\n\n  labelNames.push('_System/Processed');\n\n  if (email.confidence < 0.70) {\n    labelNames.push('_System/Review');\n  }\n\n  const labelIds = labelNames\n    .map(name => labelMap[name])\n    .filter(id => id != null);\n\n  return {\n    ...email,\n    labelsToAdd: labelIds,\n    labelNamesAdded: labelNames,\n    shouldArchive: true\n  };\n});\n"
      },
      "id": "build-labels",
      "name": "Build Labels",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1780, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://gmail.googleapis.com/gmail/v1/users/me/messages/{{ $json.messageId }}/modify",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "gmailOAuth2",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"addLabelIds\": {{ JSON.stringify($json.labelsToAdd) }},\n  \"removeLabelIds\": [\"INBOX\"]\n}",
        "options": {}
      },
      "id": "add-labels",
      "name": "Add Labels",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [2000, 200],
      "credentials": {
        "gmailOAuth2": {
          "id": "GMAIL_CREDENTIAL_ID",
          "name": "Gmail OAuth2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Handle low confidence - resolve label IDs - ALL items\nconst items = $input.all();\nconst staticData = $getWorkflowStaticData('global');\nconst labelMap = staticData.labelMap || {};\n\nconst labelNames = ['_System/Processed', '_System/Review'];\nconst labelIds = labelNames\n  .map(name => labelMap[name])\n  .filter(id => id != null);\n\nreturn items.map(item => {\n  const email = item.json;\n  return {\n    ...email,\n    labelsToAdd: labelIds,\n    labelNamesAdded: labelNames,\n    shouldArchive: true\n  };\n});\n"
      },
      "id": "low-confidence",
      "name": "Low Confidence Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1780, 400]
    }
  ],
  "connections": {
    "Gmail Trigger": {
      "main": [
        [
          {
            "node": "Fetch Labels",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Labels": {
      "main": [
        [
          {
            "node": "Cache Labels",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cache Labels": {
      "main": [
        [
          {
            "node": "Preprocess Email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preprocess Email": {
      "main": [
        [
          {
            "node": "Check Sender Cache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Sender Cache": {
      "main": [
        [
          {
            "node": "Cached?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cached?": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "AI Classification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Classification": {
      "main": [
        [
          {
            "node": "Parse AI Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse AI Response": {
      "main": [
        [
          {
            "node": "Update Cache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Cache": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Results": {
      "main": [
        [
          {
            "node": "High Confidence?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "High Confidence?": {
      "main": [
        [
          {
            "node": "Build Labels",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Low Confidence Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Labels": {
      "main": [
        [
          {
            "node": "Add Labels",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Low Confidence Handler": {
      "main": [
        [
          {
            "node": "Add Labels",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Labels": {
      "main": [
        []
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    { "name": "email" },
    { "name": "automation" }
  ],
  "triggerCount": 1,
  "pinData": {}
}
