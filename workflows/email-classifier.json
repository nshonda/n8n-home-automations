{
  "name": "Gmail Email Classifier",
  "nodes": [
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "everyX",
              "value": 5,
              "unit": "minutes"
            }
          ]
        },
        "filters": {
          "q": "in:inbox is:unread -label:_System/Processed"
        },
        "options": {
          "maxResults": 10
        }
      },
      "id": "gmail-trigger",
      "name": "Gmail Trigger",
      "type": "n8n-nodes-base.gmailTrigger",
      "typeVersion": 1,
      "position": [240, 300],
      "credentials": {
        "gmailOAuth2": {
          "id": "GMAIL_CREDENTIAL_ID",
          "name": "Gmail OAuth2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract and preprocess email content\nconst email = $input.first().json;\n\n// Get sender email\nconst fromHeader = email.payload?.headers?.find(h => h.name === 'From')?.value || '';\nconst senderMatch = fromHeader.match(/<([^>]+)>/) || fromHeader.match(/([\\w.+-]+@[\\w.-]+)/);\nconst senderEmail = senderMatch ? senderMatch[1].toLowerCase() : fromHeader.toLowerCase();\nconst senderDomain = senderEmail.split('@')[1] || '';\n\n// Get subject\nconst subject = email.payload?.headers?.find(h => h.name === 'Subject')?.value || '(no subject)';\n\n// Get body - handle multipart\nlet body = '';\nif (email.payload?.body?.data) {\n  body = Buffer.from(email.payload.body.data, 'base64').toString('utf-8');\n} else if (email.payload?.parts) {\n  const textPart = email.payload.parts.find(p => p.mimeType === 'text/plain');\n  if (textPart?.body?.data) {\n    body = Buffer.from(textPart.body.data, 'base64').toString('utf-8');\n  }\n}\n\n// Strip HTML tags if present\nbody = body.replace(/<[^>]*>/g, ' ');\n\n// Remove quoted replies (lines starting with >)\nbody = body.split('\\n').filter(line => !line.trim().startsWith('>')).join('\\n');\n\n// Remove excessive whitespace\nbody = body.replace(/\\s+/g, ' ').trim();\n\n// Truncate to 1500 chars\nconst bodyPreview = body.substring(0, 1500);\n\nreturn {\n  messageId: email.id,\n  threadId: email.threadId,\n  senderEmail,\n  senderDomain,\n  subject,\n  bodyPreview,\n  snippet: email.snippet || '',\n  labelIds: email.labelIds || []\n};\n"
      },
      "id": "preprocess",
      "name": "Preprocess Email",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "jsCode": "// Check sender cache for known classifications\nconst email = $input.first().json;\nconst staticData = $getWorkflowStaticData('global');\n\n// Initialize cache if needed\nif (!staticData.senderCache) {\n  staticData.senderCache = {};\n}\nif (!staticData.domainCache) {\n  staticData.domainCache = {};\n}\n\nconst cache = staticData.senderCache;\nconst domainCache = staticData.domainCache;\n\n// Check exact sender match first\nif (cache[email.senderEmail]) {\n  const cached = cache[email.senderEmail];\n  return {\n    ...email,\n    cached: true,\n    category: cached.category,\n    priority: cached.priority,\n    action_needed: cached.action_needed,\n    archive: cached.archive,\n    confidence: 0.95,\n    summary: `Cached classification for ${email.senderEmail}`\n  };\n}\n\n// Check domain pattern match\nif (domainCache[email.senderDomain]) {\n  const cached = domainCache[email.senderDomain];\n  return {\n    ...email,\n    cached: true,\n    category: cached.category,\n    priority: cached.priority,\n    action_needed: cached.action_needed,\n    archive: cached.archive,\n    confidence: 0.85,\n    summary: `Domain pattern match for ${email.senderDomain}`\n  };\n}\n\n// No cache hit - needs AI classification\nreturn {\n  ...email,\n  cached: false\n};\n"
      },
      "id": "cache-check",
      "name": "Check Sender Cache",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.cached }}",
              "value2": true
            }
          ]
        }
      },
      "id": "if-cached",
      "name": "Cached?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [900, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.anthropic.com/v1/messages",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "anthropic-version",
              "value": "2023-06-01"
            },
            {
              "name": "content-type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"claude-3-haiku-20240307\",\n  \"max_tokens\": 256,\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"You are an email classification system. Analyze this email and return ONLY valid JSON.\\n\\nCategories: Finance, Work, Personal, Shopping, Travel, Notifications, Newsletters, Social, Receipts, Security, Other\\n\\nPriority Levels:\\n- P1 (Urgent): Response needed within 24h, important contacts, deadlines\\n- P2 (Important): Action needed but not urgent\\n- P3 (Low): Informational, automated, promotional\\n\\nEmail:\\nFrom: {{ $json.senderEmail }}\\nSubject: {{ $json.subject }}\\nBody: {{ $json.bodyPreview.replace(/\\\"/g, '\\\\\\\"').replace(/\\n/g, ' ').substring(0, 1000) }}\\n\\nReturn JSON:\\n{\\n  \\\"category\\\": \\\"<category>\\\",\\n  \\\"priority\\\": \\\"P1|P2|P3\\\",\\n  \\\"action_needed\\\": true|false,\\n  \\\"archive\\\": true|false,\\n  \\\"confidence\\\": 0.0-1.0,\\n  \\\"summary\\\": \\\"<one sentence>\\\"\\n}\\n\\nRules:\\n- Marketing with fake urgency (\\\"Last chance!\\\") = P3\\n- CC'd (not To'd) = usually P3\\n- Security alerts (if not self-initiated) = P1\\n- Receipts with no action = P3\"\n    }\n  ]\n}",
        "options": {}
      },
      "id": "ai-classify",
      "name": "AI Classification",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1120, 400],
      "credentials": {
        "httpHeaderAuth": {
          "id": "ANTHROPIC_CREDENTIAL_ID",
          "name": "Anthropic API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse AI response and merge with email data\nconst email = $('Check Sender Cache').first().json;\nconst aiResponse = $input.first().json;\n\nlet classification;\ntry {\n  // Extract JSON from AI response\n  const content = aiResponse.content?.[0]?.text || '';\n  const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\n  if (jsonMatch) {\n    classification = JSON.parse(jsonMatch[0]);\n  } else {\n    throw new Error('No JSON found in response');\n  }\n} catch (e) {\n  // Default classification on parse error\n  classification = {\n    category: 'Other',\n    priority: 'P2',\n    action_needed: false,\n    archive: false,\n    confidence: 0.5,\n    summary: 'Classification failed - needs review'\n  };\n}\n\nreturn {\n  ...email,\n  ...classification,\n  cached: false\n};\n"
      },
      "id": "parse-ai",
      "name": "Parse AI Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 400]
    },
    {
      "parameters": {
        "jsCode": "// Update sender cache based on classification\nconst email = $input.first().json;\nconst staticData = $getWorkflowStaticData('global');\n\n// Only cache if confidence is high enough\nif (!email.cached && email.confidence >= 0.85) {\n  if (!staticData.senderCache) staticData.senderCache = {};\n  if (!staticData.senderCounts) staticData.senderCounts = {};\n  \n  // Track consecutive classifications\n  const key = email.senderEmail;\n  if (!staticData.senderCounts[key]) {\n    staticData.senderCounts[key] = { category: email.category, count: 1 };\n  } else if (staticData.senderCounts[key].category === email.category) {\n    staticData.senderCounts[key].count++;\n  } else {\n    staticData.senderCounts[key] = { category: email.category, count: 1 };\n  }\n  \n  // Add to cache after 3 consistent classifications\n  if (staticData.senderCounts[key].count >= 3) {\n    staticData.senderCache[key] = {\n      category: email.category,\n      priority: email.priority,\n      action_needed: email.action_needed,\n      archive: email.archive,\n      addedAt: new Date().toISOString()\n    };\n  }\n}\n\nreturn email;\n"
      },
      "id": "update-cache",
      "name": "Update Cache",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1560, 400]
    },
    {
      "parameters": {
        "jsCode": "// Merge cached and AI-classified emails\nconst items = $input.all();\nreturn items.map(item => item.json);\n"
      },
      "id": "merge",
      "name": "Merge Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 200]
    },
    {
      "parameters": {
        "conditions": {
          "number": [
            {
              "value1": "={{ $json.confidence }}",
              "operation": "largerEqual",
              "value2": 0.85
            }
          ]
        }
      },
      "id": "confidence-check",
      "name": "High Confidence?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1560, 200]
    },
    {
      "parameters": {
        "jsCode": "// Build label names based on classification\nconst email = $input.first().json;\n\nconst labels = [];\n\n// Category label\nconst categoryMap = {\n  'Finance': '#Finance',\n  'Work': '#Work',\n  'Personal': '#Personal',\n  'Shopping': '#Shopping',\n  'Travel': '#Travel',\n  'Notifications': '#Notifications',\n  'Newsletters': '#Newsletters',\n  'Social': '#Social',\n  'Receipts': '#Finance/Receipts',\n  'Security': '#Security',\n  'Other': '#Other'\n};\nlabels.push(categoryMap[email.category] || '#Other');\n\n// Priority label for P1/P2\nif (email.priority === 'P1') {\n  labels.push('!Priority/Urgent');\n} else if (email.priority === 'P2' && email.action_needed) {\n  labels.push('@Action/Review');\n}\n\n// System processed label\nlabels.push('_System/Processed');\n\n// Low confidence review label\nif (email.confidence < 0.70) {\n  labels.push('_System/Review');\n}\n\nreturn {\n  ...email,\n  labelsToAdd: labels,\n  shouldArchive: email.archive && email.confidence >= 0.70\n};\n"
      },
      "id": "build-labels",
      "name": "Build Labels",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1780, 200]
    },
    {
      "parameters": {
        "operation": "addLabels",
        "messageId": "={{ $json.messageId }}",
        "labelIds": "={{ $json.labelsToAdd }}"
      },
      "id": "add-labels",
      "name": "Add Labels",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2,
      "position": [2000, 200],
      "credentials": {
        "gmailOAuth2": {
          "id": "GMAIL_CREDENTIAL_ID",
          "name": "Gmail OAuth2"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.shouldArchive }}",
              "value2": true
            }
          ]
        }
      },
      "id": "should-archive",
      "name": "Should Archive?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [2220, 200]
    },
    {
      "parameters": {
        "operation": "removeLabels",
        "messageId": "={{ $json.messageId }}",
        "labelIds": ["INBOX"]
      },
      "id": "archive",
      "name": "Archive (Remove INBOX)",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2,
      "position": [2440, 100],
      "credentials": {
        "gmailOAuth2": {
          "id": "GMAIL_CREDENTIAL_ID",
          "name": "Gmail OAuth2"
        }
      }
    },
    {
      "parameters": {},
      "id": "no-archive",
      "name": "Keep in Inbox",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [2440, 300]
    },
    {
      "parameters": {
        "jsCode": "// Handle low confidence - keep in inbox with review label\nconst email = $input.first().json;\n\nreturn {\n  ...email,\n  labelsToAdd: [\n    '_System/Processed',\n    '_System/Review'\n  ],\n  shouldArchive: false\n};\n"
      },
      "id": "low-confidence",
      "name": "Low Confidence Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1780, 400]
    }
  ],
  "connections": {
    "Gmail Trigger": {
      "main": [
        [
          {
            "node": "Preprocess Email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preprocess Email": {
      "main": [
        [
          {
            "node": "Check Sender Cache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Sender Cache": {
      "main": [
        [
          {
            "node": "Cached?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cached?": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "AI Classification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Classification": {
      "main": [
        [
          {
            "node": "Parse AI Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse AI Response": {
      "main": [
        [
          {
            "node": "Update Cache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Cache": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Results": {
      "main": [
        [
          {
            "node": "High Confidence?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "High Confidence?": {
      "main": [
        [
          {
            "node": "Build Labels",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Low Confidence Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Labels": {
      "main": [
        [
          {
            "node": "Add Labels",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Low Confidence Handler": {
      "main": [
        [
          {
            "node": "Add Labels",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Labels": {
      "main": [
        [
          {
            "node": "Should Archive?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Should Archive?": {
      "main": [
        [
          {
            "node": "Archive (Remove INBOX)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Keep in Inbox",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "name": "email",
      "createdAt": "2024-01-01T00:00:00.000Z",
      "updatedAt": "2024-01-01T00:00:00.000Z"
    },
    {
      "name": "automation",
      "createdAt": "2024-01-01T00:00:00.000Z",
      "updatedAt": "2024-01-01T00:00:00.000Z"
    }
  ],
  "triggerCount": 1,
  "pinData": {}
}
